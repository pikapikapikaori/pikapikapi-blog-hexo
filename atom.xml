<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>pikapikapi-blog</title>
  
  <subtitle>李亦杨的博客</subtitle>
  <link href="https://pikapikapikaori.github.io/pikapikapi-blog-hexo/atom.xml" rel="self"/>
  
  <link href="https://pikapikapikaori.github.io/pikapikapi-blog-hexo/"/>
  <updated>2023-05-03T21:06:14.908Z</updated>
  <id>https://pikapikapikaori.github.io/pikapikapi-blog-hexo/</id>
  
  <author>
    <name>李亦杨</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>软件项目实践的一些思索与后期优化方向：设计、开发以及其他</title>
    <link href="https://pikapikapikaori.github.io/pikapikapi-blog-hexo/2023/04/28/SoftwareDevelopementInsights-20230428/"/>
    <id>https://pikapikapikaori.github.io/pikapikapi-blog-hexo/2023/04/28/SoftwareDevelopementInsights-20230428/</id>
    <published>2023-04-28T06:30:02.000Z</published>
    <updated>2023-05-03T21:06:14.908Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文首发于个人博客 <br>发表日期：2023.4.28</p></blockquote><p>大四下最后的一门课也结束了。这门课大体是由数个人组成一个小小团体进行一个小小项目从零到一的完整开发过程，不同于其他课程，这个项目要求以类似于实际开发的模式，让所有参与者都经历由需求确定、初期架构设计到中期开发、版本发布甚至于是需求变更以及迭代的完整软件开发的整个生命周期。当然其中也包括不同团队间的沟通协商。</p><p>大体而言我在其中以项目经理、架构设计、团队Leader等各种身份参与了后端的完整开发，并也作为开发者参与到了前端部分的开发任务中。个人从中确实有不少感悟，故而写此文记录。在这里主要想谈谈设计、开发的一些感想，诸如进度管理、质量把控等等可能也略有涉及。</p><h1 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h1><p>大体而言这个课程项目要求做一个宠物医院的线上学习平台，主要受众大概就是即将毕业或是正在大学学习的兽医相关专业的学生。其功能简要来讲大概有这么几类：</p><ul><li>用户管理与鉴权：常规的大系统都有的功能，这里大体上就分为管理员、出题的老师和进行学习的学生三类用户。</li><li>一个完整医院的3D全景地图与导览模型：前端开发为主的功能，本文不涉及。</li><li>系统管理：要求对这个宠物医院内诸如药物、档案、收费项目、各类检查项目、住院者的信息等等各类内容进行管理，不过这个东西似乎没有在需求文档中体现出实际的意义与用处。</li><li>病例管理：大体上是需要把来医院就诊过的各类病例收集起来存储，其包括从入院诊断、具体检查到诊断结果与治疗方案等全过程的文字图片视频信息，当然也包括得的病的信息。</li><li>测试管理：由病例管理上游的疾病部分内容衍生而来。老师根据疾病生成题库，并从中选题整理为试卷。学生则参加考试进行答题。不过这部分内容似乎与虚拟宠物医院没有太大关系。</li><li>职能学习：一方面是让学生去学习疾病的相关知识（当然要看文字图片视频），一方面学生也可以通过看文字图片视频学习医院内各类角色（医生、医助等等）的具体操作内容。</li><li>数据管理：和上面提到的图片视频的存储有关。需求上还挺麻烦的，视频格式支持太多还需要进行视频的格式转换，反应到和用户的交互上来说还需要实现分块上传等功能等。</li></ul><p>尽管后文对具体业务尽量不会涉及，但姑且将背景记于这里。不难看出这个项目还是一个比较传统的要用到数据库后端前端三个维度的项目，因而后文也主要想从这三个维度的设计与开发两方面来聊聊。</p><p>项目可以参考：</p><ul><li><a href="https://github.com/SoftwareDevelopmentPractice6/virtualPetHospital-backend">后端</a></li><li><a href="https://github.com/SoftwareDevelopmentPractice6/virtualPetHospital-frontend">前端</a></li></ul><p>本博客的仓库中也保存了相关的源码，可以参考<a href="https://github.com/pikapikapikaori/pikapikapi-blog/tree/master/resource/ITtech/SoftwareDevelopementInsights-20230428">这里</a>。</p><h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><p>由于课程要求重各类文档，因而并没有采取如今主流的敏捷开发模式，而是采取的<a href="#RAD">RAD</a>模型。个人来讲其实并不是很习惯这个模型，一方面其由瀑布式改进而来，从某种角度上还是非常重文档和前期的设计的，对需求的变更与过程中的变化并不敏感，另一方面也是因此在开发过程中的抗风险能力也非常依赖于前期的设计以及开发过程中的质量，由此带来的风险是非常恐怖的。</p><p>总之也是因此在进行前期设计时就花了相当多的时间。然而尽管如此，初期的设计还是有着比较大的漏洞，因而也给后期开发带来了一些麻烦。这些问题大多集中在数据库设计上。</p><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p>由于项目较为庞大因而一些细节的设计我也没有来得及能够去亲自把控，而是交给了同组的其他人。在这里就出了问题。上文所述的测试管理中，题库中的问题需要记录与其相关的问题类别（属于哪种病）、问题类型（单选多选）、问题内容等等。针对此负责这块内容的组员A给出了这样的设计：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">erDiagram</span><br><span class="line">Exam &#123;</span><br><span class="line">int exam_id PK</span><br><span class="line">string exam_name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Paper &#123;</span><br><span class="line">int paper_id PK</span><br><span class="line">string paper_name</span><br><span class="line">int exam_id FK</span><br><span class="line">string duration</span><br><span class="line">string total_score</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Question &#123;</span><br><span class="line">int question_id PK</span><br><span class="line">string question_content</span><br><span class="line">string question_type</span><br><span class="line">int category_id FK</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Category &#123;</span><br><span class="line">int category_id PK</span><br><span class="line">string category_name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ExamSession &#123;</span><br><span class="line">int session_id PK</span><br><span class="line">int paper_id FK</span><br><span class="line">time start_time</span><br><span class="line">time end_time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StudentResult &#123;</span><br><span class="line">int result_id PK</span><br><span class="line">int session_id FK</span><br><span class="line">int student_id</span><br><span class="line">int score</span><br><span class="line">&#125;</span><br><span class="line">Exam ||--|| Paper : relate</span><br><span class="line">Paper ||--|| ExamSession : relate</span><br><span class="line">Question &#125;o--|| Category : contains</span><br><span class="line">ExamSession ||--o&#123; StudentResult : relate</span><br></pre></td></tr></table></figure><p>且不谈同学A遗漏了需要对每张卷子上包含的题目、以及每位学生在试卷上答题所做出的回答进行存储的功能，单看<code>Question</code>与<code>Category</code>两张表。乍一看虽然是挺合理的设计，然而后者的实际有效字段只有<code>category_name</code>一栏。我不否认在大型项目中这样设计的合理性，但是考虑到这个项目的规模、以及后续可能会进行的功能上的拓展，我个人看来<code>Category</code>这张表完全冗余的。</p><p>另一方面，<code>Exam</code>、<code>Paper</code>、<code>ExamSession</code>这三张一对一的表虽然也是很符合设计原则的设计，但是同样考虑到项目规模与未来可能的拓展，这三张表就算合在一起也不会对性能与吞吐量带来很大的负担。一般来讲，只有在表中有一栏以上可能包含大量空值的情况下，或是某一些栏可能被频繁更新时，一对一关系的设计才相对合理。而在当前的情形中，这样的设计则是给后期撰写<code>SQL</code>与开发上带来了巨大的麻烦。且不谈数据的整合与处理，仅仅是外键的存在就已经带来了巨大的麻烦。这也直接导致了在后期初始化数据<code>SQL</code>撰写上耗费了大量Debug的时间，在开发的编码中也需要增加大量检测外键存在性的不必要代码。</p><h2 id="后端架构设计"><a href="#后端架构设计" class="headerlink" title="后端架构设计"></a>后端架构设计</h2><p>初期设计时我就已经敲定了<a href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1">微服务</a>的架构。通常，微服务确实不适合于本项目这样的小型项目：配置麻烦、DevOps麻烦，等等。此外，大型项目中服务间数据一致性以及安全性都是非常棘手且关键的问题。</p><p>不过事实上，我其实很看重松散耦合这一点。其给后期开发与迭代过程中带来的自由度是相当大的。前述的问题，如配置、DevOps的确相对棘手，不过包含公用模块、各类插件的配置在初期完成后便一了百了，运维上利用Docker与统一的脚本进行自动化管理也是一经配置后就极易使用的，并没有给开发人员带来很高的成本。倘若有购买服务器配置Jenkins进行更多的自动化的话，相关成本应该还能进一步降低。</p><p>实践中，jacoco、spotless、公共模块的配置实质上也仅仅耗费了我半天的时间，而后期部署时自动化测试脚本的编写仅仅耗费了我两个小时不到的时间。接口测试上所花费的时间略多一点，不过由于接口测试脚本基本是直接由swagger生成的，因而也没有耗费太多的成本。</p><p>相较于这些仅局限于初期和末期的麻烦而言，微服务架构带来的好处是实打实巨大的。数据库与模块的分离带来的是各模块开发的高独立性以及运行时的高可用性。前文所提到的数据库尽管经常会碰到组员产生的Bug，但分离的数据库使得其余的几个模块并没有受到影响从而能够很顺利的进行开发。另一方面，后端模块的分离使得几个模块都能够被快速地开发出来，也因此能够较早地将接口给到前端，从而留出了大量可用于迭代的时间。产生缺陷时查找定位的范围仅仅在自身的子系统内，因而定位缺陷的成本也略有降低。而最最重要的，由于模块间的松散耦合，即使一个服务失败其他服务也能够继续工作，这给开发与测试都带来了相当程度上的便捷。</p><p>更具体的，微服务给实践中的开发带来了巨大的便捷性。我在项目中大概采取了下图的架构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">    subgraph backend</span><br><span class="line">        subgraph modules</span><br><span class="line">            direction TB</span><br><span class="line">            subgraph module 1</span><br><span class="line">                direction LR</span><br><span class="line">                entity1 --&gt; dao1 --&gt; service1 --&gt; controller1</span><br><span class="line">            end</span><br><span class="line">            subgraph module 2</span><br><span class="line">                direction LR</span><br><span class="line">                entity2 --&gt; dao2 --&gt; service2 --&gt; controller2</span><br><span class="line">            end</span><br><span class="line">            subgraph module 3</span><br><span class="line">                direction LR</span><br><span class="line">                entity3 --&gt; dao3 --&gt; service3 --&gt; controller3</span><br><span class="line">            end</span><br><span class="line">            subgraph module 4</span><br><span class="line">                direction LR</span><br><span class="line">                entity4 --&gt; dao4 --&gt; service4 --&gt; controller4</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">        subgraph intermediator</span><br><span class="line">            direction LR</span><br><span class="line">            servicei --&gt; controlleri</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        controller1 --&gt; servicei</span><br><span class="line">        controller2 --&gt; servicei</span><br><span class="line">        controller3 --&gt; servicei</span><br><span class="line">        controller4 --&gt; servicei</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph database</span><br><span class="line">        databse1 --&gt; entity1</span><br><span class="line">        databse2 --&gt; entity2</span><br><span class="line">        databse3 --&gt; entity3</span><br><span class="line">        databse4 --&gt; entity4</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    controlleri --&gt; frontend</span><br></pre></td></tr></table></figure><p>作为微服务而言其实也是非常常见与合理的架构。中间层充当网关的角色被外部服务（前端）统一调用，其内部则再根据具体的调用请求来选择合适的服务进行通信，并将数据进行处理后转发给外部服务。在实践中，前端组与后端组同时开发，需求细节与开发细节还不明了的情况下，接口的内容与种类尽管可以大体确定，但具体的数据内容与种类等都是难以确定的。因而，利用中间层也即网关这一角色，接口确定的难题得以被解决。前后端可以先按照自己的想法对接口进行设计与模拟，当有一定的进度、对接口需求更加明确时再利用中间层进行数据的整合与处理，从而节约了大量沟通与修改的时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Frontend-&gt;&gt;+Intermediator: Request</span><br><span class="line">    Intermediator-&gt;&gt;+Module: Processed Request</span><br><span class="line">    Module--&gt;&gt;-Intermediator: Response</span><br><span class="line">    Intermediator--&gt;&gt;-Frontend: Processed Response</span><br></pre></td></tr></table></figure><p>实践上，数据的转发与整合可以由后端的网关接管，也可以由前端利用nodejs来开发，无论哪种都是非常灵活的。事实上，nodejs构建的中间层或称node层的出现，就是为了让前后端都更关注于业务本身。尽管层数的增加可能会给性能带来一些影响，然而这与开发效率所节省的成本相比是微乎其微的。由过去后端渲染html发送给浏览器的前后端不分离，到前后端分离开发再到中间层的进化，我想这是一个相当自然的过程，也非常值得去学习与应用。</p><p>此外，采取微服务架构，后期的扩展性也是相当高的。一方面，需要增加新业务时可以直接以模块为单位进行添加，而不需要再去对原有代码进行改动。另一方面，甚至也可以将同一服务运行在多台服务器上，并利用Eureka、Ribbon等等组件进行负载均衡与健康检查的功能，从而能够进一步提升可用性与性能，这些都是单体应用难以带来的好处。</p><p>当然，微服务的思想也能直接应用到前端上，也就是前些年提出的<a href="#%E5%BE%AE%E5%89%8D%E7%AB%AF">微前端</a>的思想。似乎前端组也有利用这一思想进行开发，不过本文就先不作赘述了。</p><h1 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h1><h2 id="后端开发仍存在的问题"><a href="#后端开发仍存在的问题" class="headerlink" title="后端开发仍存在的问题"></a>后端开发仍存在的问题</h2><p>开发上后端直接采用了SpringBoot的四层架构，基本上实现了增删改查四类功能。同时，调数据库方面使用了JPA。</p><p>需求上，为了满足全字段搜索、以及较简单的增删改功能，考虑到开发上的便捷性，查询相关的业务逻辑大体都是采取了下面的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> JSONObject <span class="title function_">getFeature</span><span class="params">(</span></span><br><span class="line"><span class="params">        Integer funcId,</span></span><br><span class="line"><span class="params">        String funcName,</span></span><br><span class="line"><span class="params">        String funcDescription,</span></span><br><span class="line"><span class="params">        String funcFlow,</span></span><br><span class="line"><span class="params">        String funcRole,</span></span><br><span class="line"><span class="params">        String funcTool,</span></span><br><span class="line"><span class="params">        String roomName)</span> &#123;</span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">    res.put(</span><br><span class="line">            Constants.featureList,</span><br><span class="line">            JSONObject.parseArray(JSON.toJSONString(featureRepository.findAll().stream()</span><br><span class="line">                    .filter(feature -&gt; SearchJudgeHelper.softEquals(funcName, feature.getFuncName())</span><br><span class="line">                            &amp;&amp; SearchJudgeHelper.softIncludes(funcDescription, feature.getFuncDescription())</span><br><span class="line">                            &amp;&amp; SearchJudgeHelper.softIncludes(funcFlow, feature.getFuncFlow())</span><br><span class="line">                            &amp;&amp; SearchJudgeHelper.softIncludes(funcRole, feature.getFuncRole())</span><br><span class="line">                            &amp;&amp; SearchJudgeHelper.softEquals(funcTool, feature.getFuncTool())</span><br><span class="line">                            &amp;&amp; SearchJudgeHelper.softEquals(</span><br><span class="line">                                    roomName, feature.getFeatureRoom().getRoomName())</span><br><span class="line">                            &amp;&amp; SearchJudgeHelper.softEquals(funcId, feature.getFuncId()))</span><br><span class="line">                    .collect(Collectors.toList()))));</span><br><span class="line">    <span class="keyword">return</span> ResponseHelper.constructSuccessResponse(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先说查询逻辑。为了少写<code>SQL</code>因而这里是直接调用了JPA的<code>findAll</code>方法，随后利用<code>Java</code>的流函数对其进行遍历筛选，由此得到目标结果以返回。判断相等或包含的方法由自建类进行处理，以满足空数值的比较操作，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">softEquals</span><span class="params">(String toBeJudged, String referencedValue)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Objects.equals(toBeJudged, <span class="literal">null</span>) || Objects.equals(toBeJudged, <span class="string">&quot;&quot;</span>))</span><br><span class="line">                ? <span class="literal">true</span></span><br><span class="line">                : Objects.equals(referencedValue, URLDecoder.decode(toBeJudged, Constants.UTF8));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小型项目中这样的写法大体上是没什么问题的，但如果遇上较大的项目这样的写法绝对会出很大的问题。一来，论谁都能看出的遍历查询的性能问题，在十万级别数据量下大概就能有很直观的感受了，这一工作本来应该在数据库中利用索引来优化解决。二来，大量的吞吐量给服务器带来了IO上巨大负担。其潜在的风险是难以估量的。</p><p>为了在满足需求的基础上尽可能简化开发上的工作量（即少写<code>SQL</code>与对应的函数），我目前的想法是利用正则表达式（例如MySQL中的<code>REGEXP</code>关键字）进行查询，由此将查询的相关工作返还给数据库。利用数据库内部的索引等机制对查询进行优化（MySQL内部索引的B+树能带来数倍的性能），借此来消除服务器的负担。借由这一方法全字段搜索可以通过唯一的一条<code>SQL</code>来实现，也符合尽量不写<code>SQL</code>的原则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dao层</span></span><br><span class="line"><span class="meta">@Query(value = &quot;SELECT f.* FROM Feature f WHERE (f.name REGEXP :funcNameRegExp) AND (f.description REGEXP :funcDescriptionRegExp)&quot;, nativeQuery = true)</span></span><br><span class="line">ArrayList&lt;Feature&gt; <span class="title function_">findFeatureByRegExp</span><span class="params">(<span class="meta">@Param(&quot;funcNameRegExp&quot;)</span> String funcNameRegExp, <span class="meta">@Param(&quot;funcDescriptionRegExp&quot;)</span> String funcDescriptionRegExp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Service层</span></span><br><span class="line"><span class="keyword">public</span> JSONObject <span class="title function_">getFeature</span><span class="params">(</span></span><br><span class="line"><span class="params">        String funcName,</span></span><br><span class="line"><span class="params">        String funcDescription)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">funcNameRegExp</span> <span class="operator">=</span> funcName;</span><br><span class="line">    <span class="type">String</span> <span class="variable">funcDescriptionRegExp</span> <span class="operator">=</span>  <span class="string">&quot;^&quot;</span> + funcName + <span class="string">&quot;$&quot;</span>;</span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">    res.put(</span><br><span class="line">            Constants.featureList,</span><br><span class="line">            JSONObject.parseArray(JSON.toJSONString(featureRepository.findFeatureByRegExp(funcNameRegExp, funcDescriptionRegExp))));</span><br><span class="line">    <span class="keyword">return</span> ResponseHelper.constructSuccessResponse(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再说增删改。项目中这些功能的实现大体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">\\ 增</span><br><span class="line"><span class="keyword">public</span> JSONObject <span class="title function_">addExamine</span><span class="params">(String examineName, <span class="type">double</span> examinePrice, String roomName)</span> &#123;</span><br><span class="line">    List&lt;Examine&gt; targetExamineList = examineRepository.findAll().stream()</span><br><span class="line">            .filter(examine -&gt; Objects.equals(examine.getExamineName(), examineName))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Objects.equals(targetExamineList.size(), <span class="number">0</span>)) &#123;</span><br><span class="line">        Optional&lt;Room&gt; targetRoomOptional = roomRepository.findById(roomName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (targetRoomOptional.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> ResponseHelper.constructFailedResponse(ResponseHelper.requestErrorCode);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Examine</span> <span class="variable">newExamine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Examine</span>();</span><br><span class="line">            newExamine.setExamineName(examineName);</span><br><span class="line">            newExamine.setExaminePrice(examinePrice);</span><br><span class="line">            newExamine.setExamineRoom(targetRoomOptional.get());</span><br><span class="line"></span><br><span class="line">            <span class="type">Examine</span> <span class="variable">addedExamine</span> <span class="operator">=</span> examineRepository.saveAndFlush(newExamine);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ResponseHelper.constructSuccessResponse(addedExamine);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseHelper.constructFailedResponse(ResponseHelper.requestErrorCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">\\ 改</span><br><span class="line"><span class="keyword">public</span> JSONObject <span class="title function_">updateExamine</span><span class="params">(<span class="type">int</span> examineId, String examineName, <span class="type">double</span> examinePrice, String roomName)</span> &#123;</span><br><span class="line">    Optional&lt;Examine&gt; targetExamineOptional = examineRepository.findById(examineId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (targetExamineOptional.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseHelper.constructFailedResponse(ResponseHelper.requestErrorCode);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Examine&gt; targetExamineList = examineRepository.findAll().stream()</span><br><span class="line">                .filter(examine -&gt; Objects.equals(examine.getExamineName(), examineName)</span><br><span class="line">                        &amp;&amp; !Objects.equals(examine.getExamineId(), examineId))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        Optional&lt;Room&gt; targetRoomOptional = roomRepository.findById(roomName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (targetRoomOptional.isEmpty() || !Objects.equals(targetExamineList.size(), <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ResponseHelper.constructFailedResponse(ResponseHelper.requestErrorCode);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Examine</span> <span class="variable">targetExamine</span> <span class="operator">=</span> targetExamineOptional.get();</span><br><span class="line">            targetExamine.setExamineName(examineName);</span><br><span class="line">            targetExamine.setExaminePrice(examinePrice);</span><br><span class="line">            targetExamine.setExamineRoom(targetRoomOptional.get());</span><br><span class="line"></span><br><span class="line">            <span class="type">Examine</span> <span class="variable">updatedExamine</span> <span class="operator">=</span> examineRepository.saveAndFlush(targetExamine);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ResponseHelper.constructSuccessResponse(updatedExamine);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">\\ 删</span><br><span class="line"><span class="keyword">public</span> JSONObject <span class="title function_">deleteExamine</span><span class="params">(<span class="type">int</span> examineId)</span> &#123;</span><br><span class="line">    Optional&lt;Examine&gt; targetExamineOptional = examineRepository.findById(examineId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (targetExamineOptional.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseHelper.constructFailedResponse(ResponseHelper.requestErrorCode);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        examineRepository.deleteById(examineId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (examineRepository.findById(examineId).isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> ResponseHelper.constructSuccessResponse(targetExamineOptional.get());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ResponseHelper.constructFailedResponse(ResponseHelper.requestErrorCode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说实话每个表增删改查写一遍还是挺繁琐的，毕竟业务逻辑上太过类似了。基本上都是这样的逻辑：</p><ul><li>增：查询重复数据存在情况$\rightarrow$查外键存在情况$\rightarrow$插入数据。</li><li>改：查自身数据存在情况$\rightarrow$查询重复数据存在情况$\rightarrow$查外键存在情况$\rightarrow$插入数据。</li><li>删：直接调用JPA的<code>deleteById</code>方法。</li></ul><p>这里的如果需要重构可以考虑利用<a href="#java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><code>Java</code>反射机制</a>。事实上，项目末期时根据前端需求增加的根据数据Id查询功能就是利用这一机制写的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeneralService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RoomRepository roomRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FeatureRepository featureRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AdmissionRepository admissionRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ArchiveRepository archiveRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ChargeRepository chargeRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ExamineRepository examineRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MedicineRepository medicineRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> JSONObject <span class="title function_">getDataById</span><span class="params">(String tableName, <span class="type">int</span> id)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class&lt;?&gt; dataDaoClass = Class.forName(</span><br><span class="line">                Constants.projectPackageName + <span class="string">&quot;.&quot;</span> + Constants.systemModulePackageName + <span class="string">&quot;.&quot;</span></span><br><span class="line">                        + Constants.daoClassPackageName</span><br><span class="line">                        + <span class="string">&quot;.&quot;</span> + tableName</span><br><span class="line">                        + Constants.daoClassSuffix,</span><br><span class="line">                <span class="literal">true</span>,</span><br><span class="line">                Thread.currentThread().getContextClassLoader().getParent());</span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">getByIdMethod</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Method classMethods : dataDaoClass.getMethods()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(classMethods.getName(), Constants.findByIdMethodName)) &#123;</span><br><span class="line">                getByIdMethod = classMethods;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Field selfField : <span class="built_in">this</span>.getClass().getDeclaredFields()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(selfField.getType().getName(), dataDaoClass.getName())) &#123;</span><br><span class="line">                Optional&lt;?&gt; getIdRes = (Optional&lt;?&gt;) getByIdMethod.invoke(selfField.get(<span class="built_in">this</span>), id);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (getIdRes.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ResponseHelper.constructFailedResponse(ResponseHelper.requestErrorCode);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> ResponseHelper.constructSuccessResponse(getIdRes.get());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ResponseHelper.constructFailedResponse(ResponseHelper.requestErrorCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，删除功能可以直接套用这一写法。当然，在上面的<code>getDataById</code>方法中查找<code>Method</code>与<code>Field</code>的逻辑也可以进一步进行优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;JPARepository&gt; <span class="title function_">getDataDaoClassByTableName</span> <span class="params">(String tableName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> Class.forName(</span><br><span class="line">            Constants.projectPackageName + <span class="string">&quot;.&quot;</span> + Constants.systemModulePackageName + <span class="string">&quot;.&quot;</span></span><br><span class="line">                    + Constants.daoClassPackageName</span><br><span class="line">                    + <span class="string">&quot;.&quot;</span> + tableName</span><br><span class="line">                    + Constants.daoClassSuffix,</span><br><span class="line">            <span class="literal">true</span>,</span><br><span class="line">            Thread.currentThread().getContextClassLoader().getParent());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> JSONObject <span class="title function_">getDataById</span><span class="params">(String tableName, <span class="type">int</span> id)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Class&lt;?&gt; dataDaoClass = <span class="built_in">this</span>.getDataDaoClassByTableName(tableName);</span><br><span class="line">    <span class="type">Method</span> <span class="variable">getByIdMethod</span> <span class="operator">=</span> dataDaoClass.getMethod(Constants.findByIdMethodName, Integer.class);</span><br><span class="line">    <span class="type">Field</span> <span class="variable">selfField</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getDeclaredField(tableName.toFirstCharLowerCase());</span><br><span class="line"></span><br><span class="line">    Optional&lt;?&gt; getIdRes = (Optional&lt;?&gt;) getByIdMethod.invoke(selfField.get(<span class="built_in">this</span>), id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> getIdRes.isEmpty() ? ResponseHelper.constructFailedResponse(ResponseHelper.requestErrorCode) : ResponseHelper.constructSuccessResponse(getIdRes.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> JSONObject <span class="title function_">deleteDataById</span><span class="params">(String tableName, <span class="type">int</span> id)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">getDataByIdRes</span> <span class="operator">=</span> <span class="built_in">this</span>.getDataById(tableName, id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表内查询无数据</span></span><br><span class="line">    <span class="keyword">if</span> (Object.equals(getDataByIdRes.data, <span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> getDataByIdRes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; dataDaoClass = <span class="built_in">this</span>.getDataDaoClassByTableName(tableName);</span><br><span class="line">    <span class="type">Method</span> <span class="variable">deleteByIdMethod</span> <span class="operator">=</span> dataDaoClass.getMethod(Constants.deleteByIdMethodName, Integer.class);</span><br><span class="line">    <span class="type">Field</span> <span class="variable">selfField</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getDeclaredField(tableName.toFirstCharLowerCase());</span><br><span class="line"></span><br><span class="line">    deleteByIdMethod.invoke(selfField.get(<span class="built_in">this</span>), id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ResponseHelper.constructSuccessResponse(getDataByIdRes.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了进一步简化开发工作量与代码逻辑，可以考虑先创建公共类：<code>BaseEntity</code>与<code>BaseRepository</code>，使得实体类继承前者，对应的<code>dao</code>类继承后者。</p><p>对于增改功能而言，业务逻辑中唯二的区别在于判断重复条件与判断外键存在逻辑这两项。可以考虑抽象成统一的公共方法，通过接收可变个数个参数构成的List来进行判断。更具体的，其可能是下面的实现形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> JSONObject <span class="title function_">updateDataById</span><span class="params">(</span></span><br><span class="line"><span class="params">    String tableName, </span></span><br><span class="line"><span class="params">    <span class="type">int</span> id, </span></span><br><span class="line"><span class="params">    ArrayList&lt;String&gt; duplicateConditionFields, </span></span><br><span class="line"><span class="params">    ArrayList&lt;String&gt; foreignKeys,</span></span><br><span class="line"><span class="params">    Map&lt;String, String&gt; newValues</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    Class&lt;?&gt; dataEntityClass = ...; <span class="comment">// 查找对应的Entity层类</span></span><br><span class="line">    Class&lt;?&gt; dataDaoClass = ...; <span class="comment">// 查找对应的Dao层类</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">updateByIdMethod</span> <span class="operator">=</span> dataDaoClass.getMethod(<span class="string">&quot;saveAndFlush&quot;</span>); <span class="comment">// 查找保存数据的方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">findAllMethod</span> <span class="operator">=</span> dataDaoClass.getMethod(<span class="string">&quot;findAll&quot;</span>); </span><br><span class="line">    <span class="type">Field</span> <span class="variable">selfField</span> <span class="operator">=</span> ...; <span class="comment">// 找到自身类中对应的field</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">targetData</span> <span class="operator">=</span> dataEntityClass.getConstructor().newInstance(); <span class="comment">//获取要更新数据</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">isForeignKeyExist</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果满足重复条件或外键不存在则直接返回，这里可以进一步优化</span></span><br><span class="line">    <span class="keyword">for</span>(foreignKey : foreignKeys) &#123;</span><br><span class="line">        Class&lt;?&gt; foreignKeyDaoClass = Class.forName(targetData.getDeclaredField(foreignKey).getType().getName() + ...); <span class="comment">//找到外键对应Dao层类</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">findByIdMethod</span> <span class="operator">=</span> foreignKeyDaoClass.getMethod(<span class="string">&quot;findById&quot;</span>); </span><br><span class="line">        <span class="type">Field</span> <span class="variable">selfField</span> <span class="operator">=</span> ...; <span class="comment">// 找到自身类中对应的field</span></span><br><span class="line">        Optional&lt;?&gt; getIdRes = (Optional&lt;?&gt;) findByIdMethod.invoke(selfField.get(<span class="built_in">this</span>), Integer.parseInt(newValues.get(foreignKey).getId()));</span><br><span class="line">        isForeignKeyExist &amp;= !getIdRes.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;?&gt; getAllRes = (List&lt;?&gt;) findAllMethod.invoke(selfField.get(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Object.equals(getAllRes.findAll().stream().filter(data -&gt; &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">isExist</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (duplicateConditionField : duplicateConditionFields) &#123;</span><br><span class="line">            isExist &amp;= Object.equals(</span><br><span class="line">                data.getDeclaredField(duplicateConditionField).get(data), </span><br><span class="line">                targetData.getDeclaredField(duplicateConditionField).get(targetData)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isExist;</span><br><span class="line">    &#125;).collect(Collectors.toList()).size(), <span class="number">0</span>) || !isForeignKeyExist) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不满足重复条件且外键都存在时，进行数据更新</span></span><br><span class="line">    <span class="keyword">for</span> (field : targetData.getDeclaredFields()) &#123;</span><br><span class="line">        field.set(targetData, newValues.get(field.getName()).toTargetType());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    updateByIdMethod.invoke(selfField.get(<span class="built_in">this</span>), targetData);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ...; <span class="comment">// 返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到增改功能逻辑也比较类似，因而增加功能的伪代码不再再次列出。</p><p>借此，大量类似的代码也可以被大幅省略，从而大幅减少工作量，同时也减少了冗余代码。</p><p>当然，这里也可以考虑使用拼接<code>SQL</code>的方法。不过考虑到后端开发上应该尽可能不写或少写原生的<code>SQL</code>，因而这一种写法更符合规范些。</p><p>通过利用上述的写法，项目中的代码可以精简许多，由此也可以使得所需要的测试代码大幅减少，从而使得项目整体的工作量大量降低。事实上，正是由于当前项目中有大量逻辑比较类似的代码，导致为满足覆盖率所需的测试代码非常庞大，从而难以完成自动化测试代码的编写。</p><p>除此之外，一些类内的方法也可以作出一些更改。考虑到方法链的写法更加符合直觉，且也在一定程度上能提升开发效率并使代码更加简洁（尽管在一定程度上破坏了<code>.</code>运算符的原有语义，且也不是很符合 <a href="CQRS">CQRS</a>），因而我个人更倾向于尽可能使用方法链的写法。</p><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>我个人而言也作为开发人员参与到了前端组的开发中。事实上最大的优化点在于接口调用的时机。当前，前端组在页面渲染时会请求一次后端接口，获取全部数据并渲染到页面上。之后，在进行关键词查找、数据插入、数据删除时各自会调用一次接口。至此为止都是比较合理的，当数据量庞大时前端不应该负责数据的查找工作，利用在服务器侧进行过优化的查询接口比较合理。然而，前端在进行数据编辑时，则是采用下面的流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    A[页面选中数据] --&gt; B[获取数据id]</span><br><span class="line">    B --&gt; C[根据id再次调用后端接口获取全部数据]</span><br><span class="line">    C --&gt; D[根据后端返回渲染页面]</span><br><span class="line">    D --&gt; E[用户输入完成后再次调取后端更新数据接口]</span><br></pre></td></tr></table></figure><p>由于在包含全部数据的页面进行初期渲染时每条数据的全部内容前端都已经获取到，因而选中数据进入编辑页面时完全可以直接利用前端已经拿到的数据进行渲染，不需要再次调用后端端口。且不谈在网络延迟较高的情况下，上面的做法会使得用户体验较差，在服务器有大量请求的情况下，前端冗余的调用会加重服务器的负担，从而影响性能。</p><p>另一方面我也注意到，前端由于没有将方法应用到了页面渲染的各个阶段，从而导致了某些请求会被重复多次执行，这也是影响性能的一大问题。当然，最好的解决方法应是前后端都做一下防抖处理。</p><h1 id="一些其他"><a href="#一些其他" class="headerlink" title="一些其他"></a>一些其他</h1><p>开发上的问题大体如上，基本上都是后续项目中值得进行进一步更改的地方。除此以外，整个项目的生命周期中最最值得被后续继承的地方在于严格的PR-Code Review制度与文档的维护。其中前者保证了代码的质量与规范，后者则提高了有效沟通的效率。这两者才是在开发过程中降低工作量与各类成本的最关键因素。</p><h1 id="名词释义"><a href="#名词释义" class="headerlink" title="名词释义"></a>名词释义</h1><h2 id="RAD"><a href="#RAD" class="headerlink" title="RAD"></a>RAD</h2><p>快速应用开发模型（Rapid Application Development），又称V模型。似乎是为了改进瀑布式模型而在上世纪70至80年代提出的。这一模型大体上遵循下图的几个阶段：</p><p><img src="/pikapikapi-blog-hexo/2023/04/28/SoftwareDevelopementInsights-20230428/RAD-model.webp" alt="picture"></p><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>SOA（面向服务架构）的一种变体，提倡将单一应用程序划分为松耦合的服务组，每个服务可独立部署。其概念最早于2005年提出。</p><p><img src="/pikapikapi-blog-hexo/2023/04/28/SoftwareDevelopementInsights-20230428/microservice.png" alt="picture"></p><h2 id="微前端"><a href="#微前端" class="headerlink" title="微前端"></a>微前端</h2><p>2016年被正式提出，是微服务这一概念被扩展到前端的一种应用形式，便于新老项目的共存与过渡，以及项目独立开发等。</p><p><img src="/pikapikapi-blog-hexo/2023/04/28/SoftwareDevelopementInsights-20230428/mircro-frontend.png" alt="picture"></p><h2 id="Java反射机制"><a href="#Java反射机制" class="headerlink" title="Java反射机制"></a><code>Java</code>反射机制</h2><p><code>Java</code>先编译后运行，对象类型在编译期确定。在程序运行时类被动态加载，当类没被用到时没有被加载到JVM，因而利用反射，可以在运行时获得类的各种内容。通过利用反射，可以动态地创建对象，更加灵活，但是会消耗系统资源。</p><h2 id="CQRS"><a href="#CQRS" class="headerlink" title="CQRS"></a>CQRS</h2><p>Command Query Responsibility Segregation，即命令查询职责分离模式，要求一个方法更改对象的状态或返回一个结果，但是不能同时包含这两个行为。从某种角度来说算是继承了从前将系统交互视为CRUD的思想。相较之下，方法链（Method Chaining）语法中由于对象被引用一次即可被多次调用，从某种意义上违反了这一原则。</p><p>更具体的，符合CQRS与<code>.</code>运算符原有语义（<code>调用者.操作名</code>）的写法形如下面的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.getWater();</span><br><span class="line">p.drinkWater();</span><br><span class="line">p.getThirsty();</span><br></pre></td></tr></table></figure><p>而方法链则形如下面的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Person</span>().getWater().drinkWater().getThirsty();</span><br></pre></td></tr></table></figure><p>这种写法更符合直觉，同时可以节省临时变量、简化代码。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>When I should use one to one relationship? (2012, September 7). Stack Overflow. <a href="https://stackoverflow.com/questions/12318870/when-i-should-use-one-to-one-relationship">https://stackoverflow.com/questions/12318870/when-i-should-use-one-to-one-relationship</a></li><li>search using regex in JPA. (2020, June 15). Stack Overflow. <a href="https://stackoverflow.com/questions/62379559/search-using-regex-in-jpa">https://stackoverflow.com/questions/62379559/search-using-regex-in-jpa</a></li><li>Using Java Reflection. (n.d.). Using Java Reflection. <a href="https://www.oracle.com/technical-resources/articles/java/javareflection.html">https://www.oracle.com/technical-resources/articles/java/javareflection.html</a></li><li>Rapid application development - Wikipedia. (2014, July 2). Rapid Application Development - Wikipedia. <a href="https://en.wikipedia.org/wiki/Rapid_application_development">https://en.wikipedia.org/wiki/Rapid_application_development</a></li><li>Jackson, C. (2019, June 19). Micro Frontends. martinfowler.com. <a href="https://martinfowler.com/articles/micro-frontends.html">https://martinfowler.com/articles/micro-frontends.html</a></li><li>M. (n.d.). CQRS pattern - Azure Architecture Center. CQRS Pattern - Azure Architecture Center | Microsoft Learn. <a href="https://learn.microsoft.com/en-us/azure/architecture/patterns/cqrs">https://learn.microsoft.com/en-us/azure/architecture/patterns/cqrs</a></li><li>Method chaining - why is it a good practice, or not? (2009, July 9). Stack Overflow. <a href="https://stackoverflow.com/questions/1103985/method-chaining-why-is-it-a-good-practice-or-not">https://stackoverflow.com/questions/1103985/method-chaining-why-is-it-a-good-practice-or-not</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文首发于个人博客 &lt;br&gt;发表日期：2023.4.28&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大四下最后的一门课也结束了。这门课大体是由数个人组成一个小小团体进行一个小小项目从零到一的完整开发过程，不同于其他课程，这个项目要求以类似于实际开发</summary>
      
    
    
    
    <category term="技术" scheme="https://pikapikapikaori.github.io/pikapikapi-blog-hexo/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="开发" scheme="https://pikapikapikaori.github.io/pikapikapi-blog-hexo/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>大量私货的10年代十佳动画</title>
    <link href="https://pikapikapikaori.github.io/pikapikapi-blog-hexo/2020/01/05/10TenBest-20200105/"/>
    <id>https://pikapikapikaori.github.io/pikapikapi-blog-hexo/2020/01/05/10TenBest-20200105/</id>
    <published>2020-01-05T07:56:24.000Z</published>
    <updated>2023-05-03T21:06:14.880Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/pikapikapi-blog-hexo/2020/01/05/10TenBest-20200105/cover-picture.jpg" alt="Cover"></p><blockquote><p>本文首发于<a href="https://zhuanlan.zhihu.com/p/101060618">知乎</a><br>发表日期：2020.1.5</p></blockquote><p>随着2020年到来，最近评价10年代十佳动画的问题下有很多人选出了自己心目中的个人十佳。我一直觉得要选出一份客观的榜单永远是不可能的，因而在考试周前逃避复习的同时就简单写写10年代我最喜欢的十部动画片，也算作是自己看动画的第一个十年的一份总结好了。当然，这个排列极端个人化，大家就当看个乐好了。</p><p>我是扳机黑，因而十佳没有脱离噶的片。</p><p>那么就按时间顺序简单罗列一下：</p><h1 id="《ハートキャッチプリキュア-》"><a href="#《ハートキャッチプリキュア-》" class="headerlink" title="《ハートキャッチプリキュア!》"></a>《ハートキャッチプリキュア!》</h1><blockquote><p>中文名：Heart Catch 光之美少女! <br>播出时间：2010.2</p></blockquote><p><img src="/pikapikapi-blog-hexo/2020/01/05/10TenBest-20200105/picture-1.webp" alt="Picture"></p><p><em>配图是C96在企业摊上买马越画集时赠送的色纸，在小英雄和抓心中毫不犹豫的选了抓心</em></p><p>公认的最佳Q娃</p><p>魔法少女类的动画也算是看过一些，东大妈的光美系列应当算是这些年比较知名的系列了。应当说，撇去子供向动画片本身所有的缺陷与劝退之处，抓心的其他方面强好的令人咋舌。</p><h1 id="《STAR-DRIVER-輝きのタクト》"><a href="#《STAR-DRIVER-輝きのタクト》" class="headerlink" title="《STAR DRIVER 輝きのタクト》"></a>《STAR DRIVER 輝きのタクト》</h1><blockquote><p>中文名：银河美少年 <br>播出时间：2010.10</p></blockquote><p><img src="/pikapikapi-blog-hexo/2020/01/05/10TenBest-20200105/picture-2.webp" alt="Picture"></p><p>10年骨头社做的这部萝卜在我看来基本可以算是10年代最好的萝卜片之一了。就内核上来看虽然还是少革那一套东西，但在10年代还能看到有如此作画的萝卜片本身就是一件难得的事情。上次在壁吧视频里被采访的时候我提到了桥本在银河美少年里的作画，事实上，除去桥本，本片还请到了田中、村木、今石等一众一流原画。我想，不论是哪个喜欢萝卜片的动画爱好者，银河美少年作为10年代的萝卜片在他心中一定有着举足轻重的地位。</p><h1 id="《REDLINE》"><a href="#《REDLINE》" class="headerlink" title="《REDLINE》"></a>《REDLINE》</h1><blockquote><p>中文名：红线 <br>播出时间：2010.10</p></blockquote><p><img src="/pikapikapi-blog-hexo/2020/01/05/10TenBest-20200105/picture-3.webp" alt="Picture"></p><p>小池健的红线</p><p>没什么好说的。热血的赛车动画，浪漫的结局，还有强无敌的作画带给观众的强烈视觉冲击力，实在让人难以忘怀。</p><h1 id="《THE-iDOLM-STER》"><a href="#《THE-iDOLM-STER》" class="headerlink" title="《THE iDOLM@STER》"></a>《THE iDOLM@STER》</h1><blockquote><p>中文名：偶像大师 <br>播出时间：2011.7</p></blockquote><p><img src="/pikapikapi-blog-hexo/2020/01/05/10TenBest-20200105/picture-4.webp" alt="Picture"></p><p>最棒的偶像动画</p><p>我觉得 不知道偶像大师厉害之处的人，应该是不会看得下去我之前的大部分回答和文章的。这也是很多人的10年代最佳动画之一，不再多说了。</p><h1 id="《遊☆戯☆王ARC-V》"><a href="#《遊☆戯☆王ARC-V》" class="headerlink" title="《遊☆戯☆王ARC-V》"></a>《遊☆戯☆王ARC-V》</h1><blockquote><p>中文名：游戏王arc-v <br>播出时间：2014.4</p></blockquote><p><img src="/pikapikapi-blog-hexo/2020/01/05/10TenBest-20200105/picture-5.webp" alt="Picture"></p><p>世纪粪作游戏王arcv，无论是漫画还是动画都做出了难以置信的操作。事实上，我感觉在骂它的那么多人中，真正看完动画和漫画的人应当不多。</p><p>作为一个游戏王决斗者，我对arcv的情感是极其复杂的。仅说动画，谁也无法否认设立四个世界次元这一想法的创新性。要知道，按以前的惯例，游戏王动画中极少会出现前代的特招方式，而arcv的出现，则打破了这一传统，将融合同调超量相结合，这也或多或少的影响了之后的vrains（无论是左领导的崇高力量，还是角色们的前代召唤方式的强力怪兽，这样的复古，在我看来，有arcv的影响）。另一方面，魔法卡与怪兽卡的结合，即灵摆怪兽，这一创意也使得决斗的展开变得更加复杂，也因而更容易作出帅气的操作。可惜实卡却往往偏向一方，难以做到魔法怪兽效果的平衡。动作决斗的想法也能够将所谓的“闪光抽卡”出现次数减少，可惜，大量的使用使得决斗构成难看了很多，尤其是漫画的动作卡烧4000LP实在是意想不到。</p><p>值得一提的一点是，用决斗带来笑容这一思想核心本身，实际上也是有很多挖掘空间的。许多作品都会有主角想给大家带来笑容这一桥段的出现；娱乐决斗的观念、EM魔术师卡组以及P召唤这些都与决带笑这一思想内核相符，倘若上代务不抽风，我想，这作游戏王是本可以成为一流的动画的。</p><p>可惜了这么好的点子啊。</p><p>顺便一提，亏我期待20周年纪念作这么久，之前的jump festival真是让我失望啊。</p><h1 id="《スペース☆ダンディ》"><a href="#《スペース☆ダンディ》" class="headerlink" title="《スペース☆ダンディ》"></a>《スペース☆ダンディ》</h1><blockquote><p>中文名：太空丹迪 两季 <br>播出时间：2014.1&#x2F;2014.7</p></blockquote><p><img src="/pikapikapi-blog-hexo/2020/01/05/10TenBest-20200105/picture-6.webp" alt="Picture"></p><p>BONES。渡边信一郎。菅野洋子。单元剧。</p><p>应当说，太空丹迪充满了我热爱的元素。单元剧给了创作者无尽的发挥空间，这么想来，能制作这么一部动画片，创作者们应当也是很开心的。也正是在这部动画里，中村豊画出了他最为人知名和称道的片段：那段由中村自己设计编舞的舞蹈。</p><h1 id="《SHIROBAKO》"><a href="#《SHIROBAKO》" class="headerlink" title="《SHIROBAKO》"></a>《SHIROBAKO》</h1><blockquote><p>中文名：白箱 <br>播出时间：2014.10</p></blockquote><p><img src="/pikapikapi-blog-hexo/2020/01/05/10TenBest-20200105/picture-7.webp" alt="Picture"></p><p>白箱厉害之处，在于它用最平常的方式来书写制作动画这样一个很平常，却又带给无数人梦想的工作。</p><p>我想，每一个自认为是动画爱好者的人，都应该看过白箱。虽然白箱所描绘的内容远比现实中制作动画这份工作要美好得多，但这并不能阻止爱好者们在观看过程中发自内心的感受到动画的魅力。</p><p>是白箱，让我们对动画的热爱更近了一步。</p><p>说来下个月白箱剧场版也要上映了，可惜要上学不能飞去日本看。</p><h1 id="《ルパン三世》"><a href="#《ルパン三世》" class="headerlink" title="《ルパン三世》"></a>《ルパン三世》</h1><blockquote><p>中文名：鲁邦三世 四期 <br>播出时间：2015.8</p></blockquote><p><img src="/pikapikapi-blog-hexo/2020/01/05/10TenBest-20200105/picture-8.webp" alt="Picture"></p><p>最棒的鲁邦。</p><p>不论你是或不是鲁邦系列的粉丝，不论你有或没有了解过鲁邦在漫画动画史中的地位，你都不应当错过这部鲁邦。制作方面的出色优秀不需多谈，四期鲁邦挖掘出了单元剧真正的魅力，呈现出了无比浪漫的故事。偷心贼鲁邦也偷走了无数观众的心。</p><h1 id="《フリップフラッパーズ》"><a href="#《フリップフラッパーズ》" class="headerlink" title="《フリップフラッパーズ》"></a>《フリップフラッパーズ》</h1><blockquote><p>中文名：flip flappers <br>播出时间：2016.10</p></blockquote><p><img src="/pikapikapi-blog-hexo/2020/01/05/10TenBest-20200105/picture-9.webp" alt="Picture"></p><p>又一部单元剧。</p><p>我一直认为单元剧能在最大程度上展现动画的本质这么一个很玄乎但却又能感受到的东西。从cb到攻壳机动队到之前提过的太空丹迪再到rolling girls，这一些能展现创作者幻想的作品往往能让观众更近的触摸到动画这一故事表达题材最最核心的地方，在观看的过程中观众也得以感受到动画所独有的魅力（这也是我为什么很喜欢渡边信一郎的原因，可惜啊，ct。）flip flappers每一处都展现出了单元剧这一形式的优势，唯一令人惋惜的就是结局太过仓促了。</p><h1 id="《リズと青い鳥》"><a href="#《リズと青い鳥》" class="headerlink" title="《リズと青い鳥》"></a>《リズと青い鳥》</h1><blockquote><p>中文名：利兹与青鸟 <br>播出时间：2018.4</p></blockquote><p><img src="/pikapikapi-blog-hexo/2020/01/05/10TenBest-20200105/picture-10.webp" alt="Picture"></p><p>不多说了 。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>看了十年动画片，看的动画有一些，不算多也不算少，对动画的见解也多少有些。总结的过程中发现17年开始好看的动画片确实越来越少了，希望20年开始，能出现更多出色的，令没怎么看过动画片的人能感受到动画魅力的动画片吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/pikapikapi-blog-hexo/2020/01/05/10TenBest-20200105/cover-picture.jpg&quot; alt=&quot;Cover&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文首发于&lt;a href=&quot;https://z</summary>
      
    
    
    
    <category term="随笔" scheme="https://pikapikapikaori.github.io/pikapikapi-blog-hexo/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="动画" scheme="https://pikapikapikaori.github.io/pikapikapi-blog-hexo/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>「FLCL」：以青春之名向平庸的反抗</title>
    <link href="https://pikapikapikaori.github.io/pikapikapi-blog-hexo/2018/09/22/FLCL-20180922/"/>
    <id>https://pikapikapikaori.github.io/pikapikapi-blog-hexo/2018/09/22/FLCL-20180922/</id>
    <published>2018-09-22T04:26:01.000Z</published>
    <updated>2023-05-03T21:06:14.884Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/pikapikapi-blog-hexo/2018/09/22/FLCL-20180922/cover-picture.jpg" alt="Cover"></p><blockquote><p>本文首发于<a href="https://zhuanlan.zhihu.com/p/45132455">知乎</a><br>发表日期：2018.9.22</p></blockquote><p>21世纪初，鹤卷和哉监督的作品「FLCL」映在了电视的屏幕上（指在电视上放碟观看OVA），其看似毫无逻辑的故事却让看过它的观众直呼过瘾。时隔18年后的今天，参与了「FLCL」动画制作的Production.I.G公司推出了其续作「FLCL Alternative」与「FLCL Progressive」，一时间让动画爱好者们激动不已。</p><p>然而，鲜有观众能在观看过后说出其讲的是个什么故事。不过，观众们并不会因好奇其所述的故事而沉迷与研究剧情之中，反而是一边大喊畅快，一边播放着the pillows乐队为其所作的插曲与主题歌。究竟是什么让「FLCL」具有如此魅力？</p><p><img src="/pikapikapi-blog-hexo/2018/09/22/FLCL-20180922/picture-1.png" alt="Picture"></p><h1 id="不拘一格的剧情"><a href="#不拘一格的剧情" class="headerlink" title="不拘一格的剧情"></a>不拘一格的剧情</h1><p>形如熨斗的Medical Mechanica在不断磨平小镇中每个人的棱角，而在身为小学生的直太的头脑中，却进行着天马行空的想象，而这又通过晴子使其成为现实。</p><p>「FLCL」不是一部能够轻易看懂的作品，尽管如此，无数观众在观看时仍是畅快的，这归功于它不常规的叙述故事的方法。通过使用非线性叙事的叙述方法，又不遵循传统剧本设计方法而大幅提高高潮部分在每一幕所占的比重，尽管让观众看得云里雾里，却借由紧凑的剧情与天马行空的想象将动画的情感提到了最高。而到了高潮部分，又通过具象化的战斗场景，使观众积聚的情感在一瞬间被宣泄出来。</p><p>尽管动画的故事本身看上去似乎十分荒谬，但「FLCL」却有着一个独特的内核：以青春之名向平庸发起的战争。青春是每一个观众都曾拥有的，而动画所展现的青春与“成熟”的冲突，正可以引起观众的共情。在动画中，通过实体化和隐喻的手段，将直太心中富有个性的孩童一面与追求着成为“成熟”的大人一面的斗争具象化。当直太举起贝斯向怪物挥去，高声呐喊的那一瞬间，正是他的青春向“成熟”所发起的斗争，而这也正能让观众回忆起自己的青春与成长。</p><p><img src="/pikapikapi-blog-hexo/2018/09/22/FLCL-20180922/picture-2.png" alt="Picture"></p><h1 id="极具力度感的作画与分镜"><a href="#极具力度感的作画与分镜" class="headerlink" title="极具力度感的作画与分镜"></a>极具力度感的作画与分镜</h1><p>受制于时代原因，「FLCL」的分镜和作画都是比较具有时代特点的：对长镜头的偏爱，摇镜、推拉镜头、晃动的镜头的大量使用，画面的常规构图……这些都是那个年代较为流行的分镜手法。而「FLCL」的特别之处，在于其将摇镜、推拉镜头快速进行，又使用较为夸张的透视，让观众很好的感受到了人物动作的力度感；演算系的作画则很好的展现了人物动作的力度与运动趋势，而今石洋之更为风格化的金田系作画也使得「FLCL」更具风格。</p><p>最让观众震撼的大概是第一话和第六话那两段类似“视频漫画”的部分。这是一个极为大胆的手段，基本可以说是“前无古人，后无来者”。通过将黑白色的漫画置于动画之中，并快速的进行格子的转换，使整段动画充斥着大量的信息，而人物快速的对话与小幅度的动作则进一步增加了动画的信息量，让观众看得极其畅快。</p><p><img src="/pikapikapi-blog-hexo/2018/09/22/FLCL-20180922/picture-3.gif" alt="Picture"></p><p><em>吉成曜在第五话中的作画片段</em></p><h1 id="ROCK-amp-ROLL"><a href="#ROCK-amp-ROLL" class="headerlink" title="ROCK &amp; ROLL"></a>ROCK &amp; ROLL</h1><p>the pillows成就了「FLCL」，「FLCL」也成就了the pillows。谁能想到the pillows能凭借着其粉丝的一部OVA动画而从此更为出名，谁有能想到the pillows的摇滚乐如此适合「FLCL」，能让观众感到如此酣畅淋漓？为什么他们的歌与「FLCL」如此般配？</p><p>the pillows的摇滚乐其实是比较传统的。但就《little busters》一曲的乐谱上来看，其有着摇滚乐的几乎一切典型特征：基于riff的编曲与进行方向不明确的和弦体现出了极强的节奏感，大量切分音与低音的运用和失真的电吉他、电贝司的器乐声使得音乐更显激情。但也仅此而已。硬要说有什么特别的话，可能只是它对于器乐的强化以及对声乐的弱化特点并不十分突出。</p><p>那么为什么the pillows的歌与「FLCL」如此般配？更多的，应该是其乐思与「FLCL」的相近。摇滚精神是什么？说到底，是反抗。the pillows借由歌词与编曲，很好的传递出了“青春与平庸的反抗”这样的主题，其与「FLCL」是如此的相匹配，也因而让《little busters》在动画爱好者心中变得如此经典。</p><p><img src="/pikapikapi-blog-hexo/2018/09/22/FLCL-20180922/picture-4.png" alt="Picture"></p><p>在「FLCL」的出色光芒下，续作「FLCL Alternative」与「FLCL Progressive」就显得逊色不少。不过，这两部续作并不像大多失望的「FLCL」粉丝所说的那样一无是处。如今自然很难再有人能够随性的达到当年那一群深知宅心的老害们所处的高度，但我们也必须承认，「FLCL Alternative」与「FLCL Progressive」中所做出的尝试，是值得肯定甚至有趣的。</p><h1 id="Alternative"><a href="#Alternative" class="headerlink" title="Alternative"></a>Alternative</h1><p>「FLCL」 「FLCL Alternative」继承了「FLCL」的主题与内核，却没有一味地进行复制，而是将新的元素融合到了里面，创造出了全新的「FLCL」。正如上村泰监督所说的那样，「FLCL Alternative」融入了不少“少女情怀”，因而大体可以将其租略的概括为“空气系与「FLCL」的结合”。</p><p>广义“空气系”动画的元素在「FLCL Alternative」里的体现是十分明显的：对爱情的懵懂，对梦想的追逐，对友情的维护……这些都在「FLCL Alternative」中有所展现，而在这样的故事主题之下，却又将「FLCL」的故事元素（如怪物以及与怪物的斗争等）加入其中，使得本该有些无趣的“空气系”具有着强烈的情感，这使得「FLCL Alternative」变得分外有趣，同时也不失激情。</p><p><img src="/pikapikapi-blog-hexo/2018/09/22/FLCL-20180922/picture-5.jpg" alt="Picture"></p><p>「FLCL Alternative」虽然如「FLCL」那样有着略显荒诞的情节，但总体上来说，通过使用大量广义“空气系”动画所常用的叙事手法，如线性叙事、对常规的少女日常故事展现、极具这类动画特色的台词话语等等，使得「FLCL Alternative」变得更易理解些。另一方面，「FLCL Alternative」在「FLCL」的基础上将“抗争”这一主题进一步具象化，也通过更加宏达的战争，使“青春与平庸的抗争”显得更加突出，这使得「FLCL Alternative」也能让观众不至于失望。</p><p>「FLCL Alternative」虽然如「FLCL」那样有着略显荒诞的情节，但总体上来说，通过使用大量广义“空气系”动画所常用的叙事手法，如线性叙事、对常规的少女日常故事展现、极具这类动画特色的台词话语等等，使得「FLCL Alternative」变得更易理解些。另一方面，「FLCL Alternative」在「FLCL」的基础上将“抗争”这一主题进一步具象化，也通过更加宏达的战争，使“青春与平庸的抗争”显得更加突出，这使得「FLCL Alternative」也能让观众不至于失望。</p><p><img src="/pikapikapi-blog-hexo/2018/09/22/FLCL-20180922/picture-6.png" alt="Picture"></p><p><em>「FLCL Alternative」中复现了许多「FLCL」中的场景，而这一幕也能让人联想到「飞跃巅峰2！」中的诺诺</em></p><p>分镜与作画手法上，「FLCL Alternative」也很能显出“新「FLCL」”特点。由赛璐璐转为如今的数码作画，「FLCL Alternative」的色彩变得更具饱和度，对光线与阴影的处理也更加完美，同时人物动作也更加的流畅。另一方面，「FLCL Alternative」的分镜也很有特点。它有着日常类动画常用的镜头语言：以生硬的切接为主，将对物件的特写，对单一人物的中近景画面，以及对多个人物的中远景相互拼接。但同时，它又使用了极具当今动作场面分镜特点的镜头：将战斗双方的中远景，对战斗一方的近景乃至特写，对旁观者的镜头相结合，同时又辅以轻微的镜头晃动等手段，以此来展现出双方的动作与位置变化与趋势。虽然这样的作画与分镜方法使得「FLCL」所强调的力度感不再那么明显，却也不失为一种有趣的做法。</p><p><img src="/pikapikapi-blog-hexo/2018/09/22/FLCL-20180922/picture-7.png" alt="Picture"></p><h1 id="Progressive"><a href="#Progressive" class="headerlink" title="Progressive"></a>Progressive</h1><p>相较于「FLCL Alternative」，「FLCL Progressive」反倒更具“美式动画”风格，其体现在画面中大量使用的过饱和色彩与弱化的阴影处理，也因此画面更显简洁。 </p><p>IG对于这一部所用的描述词是“大暴走”。在「FLCL Progressive」中很容易感受到这一特点，因而风格上反而更接近于「FLCL」了。本作通过将两组角色置于主角位置，将抗争这一主题进一步深化，并加入了针对于“青春与平庸抗争”这一主题的两个晴子的相互抗争。动画上的尝试是很容易注意到的：同样毫无逻辑的情节展开，同样无边际的畅想，甚至还同样加入了使用类似于“动态漫画”的手法的片段。事实上，这些手段的效果是很明显的。应当承认，配合着the pillows的摇滚乐，「FLCL Progressive」中不少片段实际上也在很大程度上点燃了观众的情绪。</p><p>可惜的是，对于情绪把控的不到位，使得「FLCL Progressive」虽有了「FLCL」的形，却没有继承其神，也就是说，因为其完全不能让观众看得爽，反而是其无逻辑的情节发展成为了致命的缺点。这样一味地模仿宅社曾经的做法显然是很难把动画做好的。</p><p><img src="/pikapikapi-blog-hexo/2018/09/22/FLCL-20180922/picture-8.png" alt="Picture"></p><p><em>其实「FLCL Progressive」很多设想和处理都是很不错的，只可惜在想象力和节奏安排上还差了一点</em></p><h1 id="Fooly-Cooly"><a href="#Fooly-Cooly" class="headerlink" title="Fooly Cooly"></a>Fooly Cooly</h1><p>「FLCL」的魅力到底在哪？是前文所述的剧情、分镜、音乐吗？是其天马行空的想象力、不拘一格的叙述方式、富于激情的情感氛围吗？是，但更重要的，是其“青春”这一主题。「FLCL」很好的为我们复现了青春的一切，满足了我们对青春的一切期待。在这样的基础之上，加之一切出色的表现手段，才成就了「FLCL」。</p><p>想要彻底分析清楚「FLCL」是不可能的，也是没有必要的。观众的任务仅仅在于享受这部动画，并让其点燃自己的情绪。我们不需要弄清楚「FLCL」的一切，正如动画中的那一句话所言：</p><h1 id="Never-Knows-Best"><a href="#Never-Knows-Best" class="headerlink" title="Never Knows Best"></a>Never Knows Best</h1><p><img src="/pikapikapi-blog-hexo/2018/09/22/FLCL-20180922/picture-9.jpg" alt="Picture"></p><p><img src="/pikapikapi-blog-hexo/2018/09/22/FLCL-20180922/picture-10.jpg" alt="Picture"></p><p>文章至此结束，感谢各位的阅读。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/pikapikapi-blog-hexo/2018/09/22/FLCL-20180922/cover-picture.jpg&quot; alt=&quot;Cover&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文首发于&lt;a href=&quot;https://zhuanl</summary>
      
    
    
    
    <category term="随笔" scheme="https://pikapikapikaori.github.io/pikapikapi-blog-hexo/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="动画" scheme="https://pikapikapikaori.github.io/pikapikapi-blog-hexo/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>四月赏曲——浅谈「四月是你的谎言」音乐选择</title>
    <link href="https://pikapikapikaori.github.io/pikapikapi-blog-hexo/2018/04/01/Shigatsunouso-20180401/"/>
    <id>https://pikapikapikaori.github.io/pikapikapi-blog-hexo/2018/04/01/Shigatsunouso-20180401/</id>
    <published>2018-04-01T08:22:06.000Z</published>
    <updated>2023-05-03T21:06:14.896Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/pikapikapi-blog-hexo/2018/04/01/Shigatsunouso-20180401/cover-picture.jpg" alt="Cover"></p><blockquote><p>本文首发于<a href="https://zhuanlan.zhihu.com/p/35181770">知乎</a><br>发表日期：2018.4.1</p></blockquote><h1 id="零"><a href="#零" class="headerlink" title="零."></a>零.</h1><p>春天 马上就要来了</p><p>让我与你相遇的春天 就要来了</p><p>再也没有你的春天……就要来了。</p><p><img src="/pikapikapi-blog-hexo/2018/04/01/Shigatsunouso-20180401/picture-1.jpg" alt="Picture"></p><h1 id="壹"><a href="#壹" class="headerlink" title="壹."></a>壹.</h1><p>伴随着小薰出场的，是口风琴版的《鸽子与少年》。《鸽子与少年》由久石让作曲，最初出现在宫崎骏执导的电影「天空之城」之中，是片中男主角巴斯每天早上用小号吹出的乐曲。乐曲采用六八拍，整体节奏十分欢快。</p><p>在「天空之城」开始处，每个早晨，少年巴斯都会站在房檐上，高高举起他的小号，并尽情地吹奏这首乐曲。每当此时，白鸽就会盘旋在空中，太阳也升了起来。</p><p>在「四月是你的谎言」第一话中，伴随着《鸽子与少年》，小薰在正片中第一次出场了。相似的，小薰站在一个半圆形台子上，同样有着白鸽盘旋在上空。风吹过，樱花飘落。伴随着背景中的樱花与整体泛白的画面，原本欢快的音乐也增加了一层浪漫的色彩。</p><p><img src="/pikapikapi-blog-hexo/2018/04/01/Shigatsunouso-20180401/picture-2.webp" alt="Picture"></p><h1 id="贰"><a href="#贰" class="headerlink" title="贰."></a>贰.</h1><p>小薰在比赛赛场演奏的乐曲是《A大调第九小提琴奏鸣曲（op.47）》（第一乐章），又名《克莱采奏鸣曲》。</p><p>克莱采是极具浪漫主义色彩的乐曲，甚至被誉为浪漫时期小提琴曲的巅峰之作，作曲家贝多芬曾用意大利语写到，他几乎是以协奏曲的方式来作曲的，而这一特点在第一乐章中就被体现出了。在第一乐章中，乐曲的整体风格是恢弘大气的，同时也是平静的，但小薰所演奏的克莱采，却与贝多芬作曲的版本完全不同。过于夸张的强弱对比，肆意改动作品中的原有记号，甚至是对节奏的大幅度改变，让本应具有浪漫主义色彩的一首乐曲变得有了些流行的感觉。小薰曾说过要按自己的喜好来进行演奏，而这一想法在她所演奏的克莱采中完全被展现了出来。</p><p><img src="/pikapikapi-blog-hexo/2018/04/01/Shigatsunouso-20180401/picture-3.webp" alt="Picture"></p><h1 id="叁"><a href="#叁" class="headerlink" title="叁."></a>叁.</h1><p>第三话中，小薰和公生唯一一次合奏的乐曲，是圣·桑的《序章与轮旋随想曲（op.28）<br>》。顾名思义，全曲由“序章”与“回旋曲”两部分组成。序章部分持续性的使用低音，并同时导出了慢速度的基本旋律。由于乐曲本身受到西班牙舞曲的影像，在序章部分小提琴演奏出了哈巴涅拉舞曲型的主旋律。回旋曲部分，则以切分音为基础不断重复中轻快的主旋律。有趣的是，在这样不断的重复中，却体现出了西班牙舞曲中的那种热情与奔放。这种热情与奔放伴随着小薰和公生的第一次合作，逐步把演奏推向高潮，同时也让小薰和公生的感情在演奏中更近了一步。</p><p>这首乐曲还被改编为了小薰的角色歌。很容易感受到，改编后的乐曲明显不在有那中热情奔放的感觉，正相反，配合着歌词，这首乐曲反而变得比较哀伤。从这样一个角度看，改编后的乐曲实在是非常贴合小薰的经历的。小薰在与公生相遇后改学小提琴，而后则变为小薰拯救公生，让他重拾钢琴。另一方面，背带到小薰面前的公生，也让小薰在最后的日子里能够实现一些愿望，变得幸福一些。可最终小薰还是故去了。改变后的乐曲，正如同动画的剧情一样，有这一种“凄美”的感觉。</p><p><img src="/pikapikapi-blog-hexo/2018/04/01/Shigatsunouso-20180401/picture-4.webp" alt="Picture"></p><h1 id="肆"><a href="#肆" class="headerlink" title="肆."></a>肆.</h1><p>《C大调作品第K.265&#x2F;300e》，又名《小星星变奏曲》，由莫扎特创作，后被改编为童谣。全曲由12个变奏构成，旋律单纯质朴，主题浪漫而梦幻。据传莫扎特是在1778年旅居巴黎时为一位女弟子创作的这首变奏曲。具体的创作背景已无从考证，但这种说法也不失为一段佳话。在四谎中，小薰常在公生面前唱起这首曲子。欢快的节奏和有些浪漫的创作背景都为四谎中的这些片段增添了浪漫的气息。</p><p><img src="/pikapikapi-blog-hexo/2018/04/01/Shigatsunouso-20180401/picture-5.png" alt="Picture"></p><h1 id="伍"><a href="#伍" class="headerlink" title="伍."></a>伍.</h1><p>曾有人说“小星星在你的头顶闪烁着呢”，可惜，好久都没有见到这个人了。在这样又一个四月之中，回响在耳边的只有这样几句简单的歌词：</p><blockquote><p>Twinkle, twinkle, little star<br>How I wonder what you are<br>Up above the world so high<br>Like a diamond in the sky</p></blockquote><p><img src="/pikapikapi-blog-hexo/2018/04/01/Shigatsunouso-20180401/picture-6.GIF" alt="Picture"></p><p>文章至此结束，感谢各位的阅读。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/pikapikapi-blog-hexo/2018/04/01/Shigatsunouso-20180401/cover-picture.jpg&quot; alt=&quot;Cover&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文首发于&lt;a href=&quot;https</summary>
      
    
    
    
    <category term="随笔" scheme="https://pikapikapikaori.github.io/pikapikapi-blog-hexo/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="动画" scheme="https://pikapikapikaori.github.io/pikapikapi-blog-hexo/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
</feed>
